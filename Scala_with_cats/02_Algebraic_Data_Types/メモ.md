# Algebraic Data Types

この章では、プログラミング戦略の最初の例として代数的データ型を取り上げる。
論理 AND と論理 OR を使って記述できるデータは全て代数的データ型。

代数的データ型を他の型に変換する構造的再帰スケルトン、他の型から代数的データ型を構築する構造的コアカーソンスケルトンってなんや(日本語でおk

## Building Algebraic Data Types

まず、いくつかの異なるドメインのデータの例から始めよう。
- ディスカッションフォーラムのユーザーは、通常、スクリーンネーム、メールアドレス、パスワードを持っている
- ユーザーは通常、特定の役割を持つ。たとえば、一般ユーザー、モデレーター、管理者など。 
ここから次のようなデータが得られる。
ユーザーはスクリーンネーム、メールアドレス、パスワード、ロールを持ち、ロールはノーマル、モデレーター、またはアドミニストレーターです。

2次元ベクターグラフィックスでは、形状をパスとして表現するのが一般的で、これは仮想ペンの一連の動作である。
可能なアクションは通常、直線、ベジェ曲線、または目に見える出力にならない動き。
直線には終点があり（始点は暗黙の了解）、ベジェ曲線には2つの制御点と終点があり、移動には終点がある。

上記のすべての例に共通するのは、個々の要素（原子）が論理的なandか論理的なorで接続されていること。 
例えば、ユーザーとはスクリーンネームとメールアドレスとパスワードとロールのことである。 
2Dアクションは直線やベジェ曲線や移動である。

これが代数的データ型の核心である。代数的データ型とは、論理ANDや論理ORを使って結合されたデータのことである。 
逆に言えば、論理ANDと論理ORでデータを記述できる場合はいつでも代数的データ型となる。

## Algebraic Data Types in Scala

### Algebraic Data Types in Scala 3

Scala 3では、論理ANDは`final case class`で表現される。
`final`をつけない非終端ケース・クラスはまだクラスによって拡張することができ、代数的データ型の閉じた世界の基準を破ることができるので、`final`をつけましょう。
```scala 3
final case class A(b: B, c: C)
```

 論理ORはenumによって表現される。 A is B or Cという和型の場合、Scala 3では次のように表現される。
```scala 3
enum A {
  case B
  case C
}
```
論理ANDと組み合わせて↓のようにも書ける。
```scala 3
enum A {
  case B(d: D, e: E)
  case C(f: F, g: G)
}
```

enumの中にfinal caseクラスを書く必要はない(書けない)
enumの中にenumを入れ子にすることはできないが、ネストされた論理和はフラットな論理和に書き換えることができるので（分離正規形と呼ばれる）OK。 
しかし、Scala 2の表現はScala 3でも利用可能なのでネストさせることもできなくはない。