# Functional Programming Strategies

## Three Levels for Thinking About Code

コードをパラダイム・理論・技術という三つの異なるレベルから考えるというのは面白い。
そして各レベルは下のレベルへのガイダンスとなっている点も。

パラダイムとはまた、暗黙のうちに、これらの原則に従ったコードはそうでないコードよりも優れているという主張。
関数型プログラミングでは、これらの原則は合成を可能にすること(composition)と推論(reasoning)だと筆者は考えている。

オブジェクト指向だとSOLID原則かもしれない？と述べている。

パラダイムの重要性は、さまざまな実装戦略を選択するための基準を提供するで、どのようなプログラミング問題に対してもどのようなアプローチを取るべきかを決めるために、パラダイムの原則を使う。
例えば関数型プログラマーであれば、特定の実装をいかに簡単に推論できるか、あるいはその実装がいかに合成可能(composable)であるかを考える。
理論レベルでは、パラダイムの大まかな原則をパラダイム内の多くの言語に適用できる、明確に定義されたテクニックに変換する。 例えば代数的データ型など。
技術レベルでは言語固有のニュアンスにたどり着く。 Scalaの例としては、Scala 2ではsealed traitやfinal case class、Scala 3ではenumといった代数的データ型の実装がある。

## Functional Programming

筆者は昔は関数型プログラミングを不変データと純粋関数を使ったプログラミングスタイルと捉えていたが、今ではFPの真のゴールは局所推論と合成を可能にすることだと考えているらしい。

### What Functional Programming Is

筆者曰く、関数型プログラミングはソフトウェアの品質に関する仮説。
具体的には、実行する前に理解でき、再利用可能な小さなコンポーネントで構成されているソフトウェアの方が、書きやすく保守しやすいという仮説。
最初の性質はローカル推論、2つ目はコンポジションとして知られている。

ローカル推論とは、コードの断片を単独で理解できることを意味する。 私たちが1 + 1という式を見たとき、それがこれらの外部状態に依らず何を意味するかがわかる。
合成可能性はまあなんとなくわかるでしょう。

で、これらを下支えする技術的なレイヤーとして純粋関数だとかがあると確かにしっくりきますね。

#### Types

型は関数型プログラミングの一種ではないが、推論のためのツールではあるよねと。
必須条件ではないがあると嬉しい条件くらいの感じかな？

### What Functional Programming Isn’t

不変性や評価戦略は局所的な推論や合成を可能にするという目標のための道具であって、目標そのものではない。

### Why It Matters

ここら辺はまあせやな、という内容なので省略。

### The Evidence for Functional Programming

根拠については明確な研究があるわけではなく、産業界が支持してるくらいのものっぽい。

### Final Words

まとめ